======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Cool Coatis

Processing all weeks found in repository

Your current Git repo size is about 1.44 MiB on disk

Found directories: results, data, .git, Feedback, code
Found files: .gitignore, CONTRIBUTIONS.md, README.md

Processing all weeks: code

Found 3 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: align_seqs_better.py

Contents:

**********

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
align_seqs_fasta.py
-------------------
Align two DNA sequences by sliding the shorter across the longer and scoring matches.
Records *all* equally-best alignments, saves a human-readable report and a pickle file.

Usage:
    python3 align_seqs_fasta.py seq1.fasta seq2.fasta
If no paths are provided, the script will try ./data/seq1.fasta and ./data/seq2.fasta.
If those are missing, it falls back to two built-in example sequences so it still runs.

Outputs (created under ./results/):
    - alignment_results.txt : human-readable summary
    - alignment_results.pkl : python pickle with the full results dict

This implementation follows the classic MulQuaBio "Align DNA sequences" practical.
"""

import argparse
import os
import pickle
from typing import List, Dict, Tuple

# ---------------------------
# FASTA utilities
# ---------------------------

def read_fasta(path: str) -> Tuple[str, str]:
    """Read a (single-sequence) FASTA file and return (header, sequence in uppercase)."""
    if not os.path.exists(path):
        raise FileNotFoundError(f"FASTA not found: {path}")
    header = None
    seq_parts: List[str] = []
    with open(path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            if line.startswith('>'):
                # Keep the first header, ignore subsequent ones for simplicity
                if header is None:
                    header = line[1:].strip()
            else:
                seq_parts.append(line.upper())
    seq = ''.join(seq_parts)
    if header is None:
        header = os.path.basename(path)
    return header, seq

def sanitize_dna(seq: str) -> str:
    """Uppercase and keep only A/C/G/T/N; remove others (spaces, numbers, etc.)."""
    seq = seq.upper()
    allowed = {'A', 'C', 'G', 'T', 'N'}
    return ''.join(ch for ch in seq if ch in allowed)

# ---------------------------
# Alignment core
# ---------------------------

def calculate_score(s1: str, s2: str, startpoint: int) -> int:
    """Return the number of matching bases when s2 is aligned to s1 at startpoint."""
    score = 0
    l1 = len(s1)
    l2 = len(s2)
    for i in range(l2):
        pos_in_s1 = startpoint + i
        if pos_in_s1 >= l1:
            break  # s2 hangs off the end of s1
        if s1[pos_in_s1] == s2[i]:
            score += 1
    return score

def align_sequences(raw_s1: str, raw_s2: str) -> Dict:
    """Align two sequences, returning a dict with best score and all equally-best alignments."""
    # Ensure we slide the *shorter* across the *longer*
    s1 = sanitize_dna(raw_s1)
    s2 = sanitize_dna(raw_s2)
    if len(s1) < len(s2):
        s1, s2 = s2, s1  # swap so s1 is the longer
    
    best_score = -1
    best_alignments: List[Dict] = []
    l1 = len(s1)
    l2 = len(s2)

    for start in range(0, l1):  # try all start positions on s1
        sc = calculate_score(s1, s2, start)
        if sc > best_score:
            best_score = sc
            best_alignments = [{
                'start': start,
                'aligned_s2': ('.' * start) + s2,
            }]
        elif sc == best_score:
            best_alignments.append({
                'start': start,
                'aligned_s2': ('.' * start) + s2,
            })

    return {
        's1': s1,
        's2': s2,
        'best_score': best_score,
        'best_alignments': best_alignments,
    }

# ---------------------------
# I/O helpers
# ---------------------------

def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def save_results(results: Dict, out_dir: str = 'results') -> Tuple[str, str]:
    """Save results as text and pickle in out_dir. Return (txt_path, pkl_path)."""
    ensure_dir(out_dir)
    txt_path = os.path.join(out_dir, 'alignment_results.txt')
    pkl_path = os.path.join(out_dir, 'alignment_results.pkl')

    s1 = results['s1']
    s2 = results['s2']
    best_score = results['best_score']
    best_alignments = results['best_alignments']

    # Human-readable report
    with open(txt_path, 'w', encoding='utf-8') as f:
        f.write('== DNA Alignment Results ==\n\n')
        f.write(f'Length(s): s1={len(s1)}, s2={len(s2)}\n')
        f.write(f'Best score: {best_score}\n')
        f.write(f'Number of equally-best alignments: {len(best_alignments)}\n\n')

        # Show the base sequences
        f.write('S1 (reference):\n')
        f.write(s1 + '\n\n')
        f.write('S2 (query):\n')
        f.write(s2 + '\n\n')

        f.write('--- Best alignments (all ties) ---\n')
        for i, aln in enumerate(best_alignments, 1):
            f.write(f'[{i}] start={aln["start"]}\n')
            f.write(aln['aligned_s2'] + '\n\n')

    # Pickle everything
    with open(pkl_path, 'wb') as pf:
        pickle.dump(results, pf)

    return txt_path, pkl_path

# ---------------------------
# Defaults & CLI
# ---------------------------

DEFAULTS = (
    os.path.join('..', 'data', '407228326.fasta'),
    os.path.join('..', 'data', '407228412.fasta'),
)

BUILTIN_EXAMPLE = (
    '>Example_seq_1\nGATTACAAGGTTAC\n',
    '>Example_seq_2\nTTACAGTTAC\n',
)

def main():
    parser = argparse.ArgumentParser(description='Align two DNA FASTA sequences and record all best alignments.')
    parser.add_argument('fasta1', nargs='?', help='Path to first FASTA file')
    parser.add_argument('fasta2', nargs='?', help='Path to second FASTA file')
    parser.add_argument('-o', '--outdir', default='../results', help='Output directory (default: ../results)')
    args = parser.parse_args()

    # Determine input sources
    candidates = []
    if args.fasta1 and args.fasta2:
        candidates = [args.fasta1, args.fasta2]
    else:
        candidates = list(DEFAULTS)

    try:
        if all(os.path.exists(p) for p in candidates):
            h1, s1 = read_fasta(candidates[0])
            h2, s2 = read_fasta(candidates[1])
        else:
            # fall back to built-in example sequences so the script still runs
            h1, s1 = 'Builtin_1', sanitize_dna(BUILTIN_EXAMPLE[0].split('\n', 1)[1])
            h2, s2 = 'Builtin_2', sanitize_dna(BUILTIN_EXAMPLE[1].split('\n', 1)[1])
    except Exception as e:
        print(f'[ERROR] Failed to read FASTA inputs: {e}')
        print('Falling back to built-in example sequences.')
        h1, s1 = 'Builtin_1', sanitize_dna(BUILTIN_EXAMPLE[0].split('\n', 1)[1])
        h2, s2 = 'Builtin_2', sanitize_dna(BUILTIN_EXAMPLE[1].split('\n', 1)[1])

    results = align_sequences(s1, s2)
    results['header1'] = h1
    results['header2'] = h2

    txt_path, pkl_path = save_results(results, args.outdir)
    print('Done.')
    print(f'Best score: {results["best_score"]} | #best alignments: {len(results["best_alignments"]) }')
    print(f'Report   : {txt_path}')
    print(f'Pickle   : {pkl_path}')

if __name__ == '__main__':
    main()



**********

Output (first 500 chars):

**********
Done.
Best score: 527 | #best alignments: 1
Report   : ../results/alignment_results.txt
Pickle   : ../results/alignment_results.pkl

**********
No errors.
======================================================================
Script: align_seqs_fasta.py

Contents:

**********
#!/usr/bin/env python3

"""A code that finds the best allignent for two strands of fasta files, files must be located in the data folder"""
__version__ = '0.0.1'

import sys



def import_values(file_1, file_2):
    filepath_1 = f"data/{file_1}"
    filepath_2 = f"data/{file_2}"
    with open(filepath_1, "r") as f:
        lines = f.readlines()
        seq1 = ''.join(line.strip() for line in lines if not line.startswith('>'))
    with open(filepath_2, "r") as f:
        lines = f.readlines()
        seq2 = ''.join(line.strip() for line in lines if not line.startswith('>'))
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths

    return(s1, s2, l1, l2)


def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score


def find_best_score(s1, s2, l1, l2):
    my_best_align = None
    my_best_score = -1

    for i in range(l1): # Note that you just take the last alignment with the highest score
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 # think about what this is doing!
            my_best_score = z 
    print(f"{my_best_align}\n{s1}\nBest score: {my_best_score}")
    result = f"{my_best_align}\n{s1}\nBest score: {my_best_score}"
    return result 



def main(argv):
    if len(sys.argv) != 3:
        # Default files if no arguments given
        s1, s2, l1, l2 = import_values("407228326.fasta", "407228412.fasta")
    else:
        # Use command-line arguments
        s1, s2, l1, l2 = import_values(sys.argv[1], sys.argv[2])    
    with open( '../results/aligned_seq.txt', 'w') as f:
        f.write(find_best_score(s1, s2, l1, l2))    
    return(0)


if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/CoolCoatis_/code/align_seqs_fasta.py", line 81, in <module>
    status = main(sys.argv)
             ^^^^^^^^^^^^^^
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/CoolCoatis_/code/align_seqs_fasta.py", line 71, in main
    s1, s2, l1, l2 = import_values("407228326.fasta", "407228412.fasta")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/CoolCoatis_/code/align_seqs_fasta.py", line 13, in import_values
    with open(filepath_1, "r") as f:
         ^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'data/407228326.fasta'

**********
======================================================================
Script: oaks_debugme.py

Contents:

**********
### code below
import csv
import sys
import doctest

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus' 
    >>> is_an_oak('Quercus')
    True

    >>> is_an_oak('Quercus robur')
    True

    >>> is_an_oak('quercus')
    True

    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('Quercuss')
    True

    >>> is_an_oak('Quercs')
    True

    >>> is_an_oak('Pinus')
    False

    >>> is_an_oak('')
    False

    >>> is_an_oak('QUERCUS ALBA')
    True
    """
    # Handle empty strings or None
    if not name:
        return False
    # Convert to lowercase and strip whitespace
    name_lower = name.lower().strip()
    genus = name_lower.split()[0] if ' ' in name_lower else name_lower

    if genus.startswith('quercus'):
        return True
    #Handle typos
    if genus.startswith ('q') and 5 <= len(genus) <= 9:
        target = 'quercus'
        matches = sum(1 for i, char in enumerate(genus) if i < len(target) and char == target[i])
        if matches >=5:
            return True
    return False

#main code
def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    csvwrite.writerow(['Genus', 'Species'])  # Write header to output file
    next(taxa) # Skip the header row (first line) of the input CSV

    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0

#run and test  
if (__name__ == "__main__"):
    status = main(sys.argv)

    print("\nRunning doctests...")
    doctest.testmod()
**********

Output (first 500 chars):

**********
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


Running doctests...

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 3
Scripts successful: 2
Scripts with errors: 1
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

